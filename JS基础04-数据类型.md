# 数据类型

## 基本数据类型

JavaScript 的数据类型分为两种：

- **简单的值（原始值）：包含字符串、数字和布尔值，此外，还有两个特殊值——null（空值）和 undefined（为定义）。**
- **复杂的数据结构（泛指对象）：包括狭义的对象、数组和函数。**

JavaScript 定义了 6 种基本数据类型，如表所示：

| 数据类型  | 说明                             |
| --------- | -------------------------------- |
| null      | 空值，表示非对象                 |
| undefined | 未定义的值，表示未赋值的初始化值 |
| number    | 数字，数学运算的值               |
| string    | 字符串，表示信息流               |
| boolean   | 布尔值，逻辑运算的值             |
| object    | 对象，表示复合结构的数据集       |

?> 在 JavaScript 中，函数是一种比较特殊的结构。它可以是一段代码集合，也可以是一种数据类型；可以作为对象来使用，还可以作为构造函数创建类型。JavaScript 函数的用法比较灵活，这也是 JavaScript 语言敏捷的一种表现（函数式编程）。

### Null

**Null 类型只有一个值，即 null，它表示空值，定义一个空对象指针。**

### Undefined

**undefined 是 Undefined 类型的唯一值，它表示未定义的值。当声明变量未赋值时，或者定义属性未设置值时，默认值都为 undefined。**

初始变量的默认值都为 `undefined`：

```javascript
var a; //声明变量
console.log(a);  //返回变量默认值为 undefined
```

对于函数来说，如果没有明确的返回值，则默认返回值也为

```javascript
function f(){}
console.log(f());  //返回"undefined"
```

!> undefined 隐含着意外的空值，而 null 隐含着意料之中的空值。因此，设置一个变量、参数为空值时，建议使用 null，而不是 undefined。

### 布尔型

**布尔型（Boolean）仅包含两个固定的值：`true` 和 `false`。其中，`true` 代表"真”，而 `false` 代表“假”。**

**在 JavaScript 中，`undefined`、`null`、`""`、`0`、`NaN` 和 `false` 这 6 个特殊值转换为布尔值时为 `false`，被称为假值。除了假值以外，其他任何类型的数据转换为布尔值时都是 `true`。**

```javascript
//使用 Boolean() 函数可以强制转换值为布尔值。
console.log(Boolean(0)); //返回 false
console.log(Boolean(NaN)); //返回 false
console.log(Boolean(null)); //返回 false
console.log(Boolean("")); //返回 false
console.log(Boolean(undefined)); //返回 false
```

### 字符串

**JavaScript 字符串（String）就是由零个或多个 Unicode 字符包含在单引号或双引号中的字符序列。**

1) **如果字符串包含在双引号中，则字符串内可以包含单引号；反之，也可以在单引号中包含双引号。**例如，定义 HTML 字符串时，习惯使用单引号表示字符串，HTML 中包含的属性值使用双引号表示， 这样不容易出现错误。

```javascript
console.log('<meta charset="UTF-8">');
```

2) **在 ECMAScript 3 中，字符串必须在一行内表示，换行表示是不允许的。例如，下面字符串直接量的写法是错误的。**

```javascript
console.log("字符串
直接量"); //抛出异常
```

如果要换行显示字符串，可以在字符串中添加换行符`\n`。例如：

```javascript
console.log("字符串\n直接量");  //在字符串中添加换行符
```

3) **在 ECMAScript 5 中，字符串允许多行表示。实现方法：在换行结尾处添加反斜杠`\`。反斜杠和换行符不作为字符串直接量的内容。**例如：

```javascript
console.log("字符串\
直接量");  //显示“字符串直接量”
```

4) **在字符串中插入特殊字符，需要使用转义字符，如单引号、双引号等。**例如，英文中常用单引号表示撇号，此时如果使用单引号定义字符串，就应该添加反斜杠转义字符，单引号就不再被解析为字符串标识符，而是作为撇号使用。

```javascript
console.log('I can\'t read.');  //显示"I can't read."
```

借助 String 类型的原型方法，可以灵活操作字符串。再配合正则表达式，还可以完成复杂的字符串处理任务。

**在 JavaScript 中，可以使用加号+运算符连接两个字符串，使用字符串的 length 属性获取字符串的字符个数（长度）。**下面代码先合并两个字符串，然后计算它们的长度：

```javascript
var str1 = "学而不思则罔",
    str2 = "思而不学则殆",
    string = str1 + "，" + str2;
document.write(string);  //显示“学而不思则罔，思而不学则殆”
document.write(string.length);  //显示 13
```

**JavaScript 字符串是固定不变的字符序列，虽然可以使用各种方法对字符串执行操作，但是返回的都是新的字符串，原字符串保持固定不变。此外，也不能使用 delete 运算符删除字符串中指定位置的字符。**

**在 ECMAScript 5 中，字符串可以作为只读数组使用。除了使用 `charAt()` 访问其中的字符外，还可以使用中括号运算符来访问。字符串中每个字符都有固定的位置。第 1 个字符的下标位置为 0，第 2 个字符的下标位置为 1…… 以此类推，最后一个字符的下标位置是字符串长度减1。**下面代码使用 for 语句逐个读取字符串中每个字符并显示出来。

```javascript
var str = "学而不思则罔，思而不学则殆";
for(var i=0; i<str.length; i++){
  console.log(str[i]);
}
```

!> 注意：字符串中的字符不能被 `for/in` 语句循环枚举。

### 数字

**数字（Number）也称为数值或数。**

**数值可以细分为整型直接量和浮点型直接量。浮点数就是带有小数点的数值，而整数是不带小数点的数值。**

```javascript
var int = 1;  //整型数值
var float = 1.0;  //浮点型数值
```

**JavaScript 中的所有数字都是以 64 位浮点数形式存储，包括整数。例如，2 与 2.0 是同一个数。**

浮点数可以使用科学计数法来表示。其中 e （或 E）表示底数，其值为 10，而 e 后面跟随的是 10 的指数。指数是一个整型数值，可以取正负值。

```javascript
var float = 1.2e3;
```

上述代码等价于：

```javascript
var float = 1.2*10*10*10;
var float = 1200;
```

科学计数法表示的浮点数也可以转换为普通的浮点数。

```javascript
var float = 1.2e-3;
```

等价于：

```javascript
var float = 0.0012;
```

执行数值计算时，要防止浮点数溢出。例如，0.1+0.2 并不等于 0.3。

```javascript
num = 0.1+0.2;   //0.30000000000000004
```

**这是因为 JavaScript 遵循二进制浮点数算术标准（IEEE 754）而导致的问题。这个标准适合很多应用，但它违背了数字基本常识。**

**解决方法：浮点数中的整数运算是精确的，所以小数表现出来的问题可以通过指定精度来避免。**例如，针对上面的相加可以这样进行处理。

```javascript
a = (1+2)/10;   //0.3
```

?> 这种处理经常在货币计算中用到。例如，元可以通过乘以 100 而转成分，然后就可以准确地将每项相加，求和后的结果可以除以 100 再转换回元。

使用算数运算符，数值可以参与各种计算，如加、减、乘、除等运算操作。

为了解决复杂数学运算，JavaScript 提供了大量的数值运算函数，这些函数作为 Math 对象的方法可以直接调用。

```javascript
var a = Math.floor(20.5);  //调用数学函数，向下舍入
var b = Math.round(20.5);  //调用数学函数，四舍五入
document.write(a);  //返回20
document.write(b);  //返回21
```

JavaScript 定义了几个特殊的数值常量，说明如表所示。

| 特殊值                        | 说明                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| Infinity                      | 无穷大。当数值超过浮点型所能够表示的范围；反之，负无穷大为-Infinity |
| NaN（Not a Number，非数字值） | 非数值。不等于任何数值，包括自己。如当0除以0时会返回这个特殊值 |
| Number.MAX_VALUE              | 表示最大数值                                                 |
| Number.MIN_VALUE              | 表示最小数值，一个接近0的值                                  |
| Number.NaN                    | 非数值，与NaN常量相同                                        |
| Number.POSITIVE_INFINITY      | 表示正无穷大的数值                                           |
| Number.NEGATIVE_INFINITY      | 表示负无穷大的数值                                           |

当试图将非数字形式的字符串转换为数字时或者 NaN 参与数学运算时，就会生成 NaN。因此，如果表达式的运算值为 NaN，那么可以推断其中至少一个运算数是 NaN。

```javascript
+ '0' //0
+ 'oops' //NaN
```

## 类型判断

### 使用 `typeof` 

**使用 `typeof` 可以检测数据的基本类型，类似于 Python 当中的 `type` 方法。**

`typeof` 运算符以字符串的形式返回 6 种基本类型

```javascript
console.log(typeof 1);  //返回字符串"number"
console.log(typeof "1");  //返回字符串"string"
console.log(typeof true);  //返回字符串"boolean"
console.log(typeof {});  //返回字符串"object"
console.log(typeof []);  //返回字符串"object"
console.log(typeof function(){});  //返回字符串"function"
console.log(typeof null);  //返回字符串"object"
console.log(typeof undefined) ;  //返回字符串"undefined"
```

通过比较可以发现，`typeof` 返回值与上表存在两点差异，简单说明如下：

- 把 `null` 归为 Object 类型，而不是作为一种特殊类型（Null）的值。
- 把 `function(,){}` 归为 Function 类型。即把函数视为一种独立的基本数据类型，而不是 Object 类型的一种特殊子类。

由于 null 值返回类型为 Object，使用下面自定义函数可以避开因为 null 值影响基本类型检测。

```javascript
//如果是 null 值，则先返回字符串 "null" 否则返回（typeof o）的值
function typeOf(o){
    return (o === null) ? "null" : (typeof o);
}
console.log(typeOf(null));  //返回字符串"null"
```

!> `typeof` 不能分辨数字和 NaN，并且 NaN 不等同于它自己。

### 使用 `isNaN`

**使用 `isNaN()` 全局函数可以判断 NaN。**

```javascript
isNaN(NaN) //true
isNaN(0) //false
isNaN('oops') //true
isNaN('0') //false
```

### 使用 `isFinite`

**使用 `isFinite()` 全局函数可以判断 NaN 和 Infinity（无穷大）。**因此，可以使用它来检测 NaN、正负无穷大。如果是有限数值，或者可以转换为有限数值，那么将返回 `true`。如果只是 NaN、正负无穷大的数值，则返回 `false`。

```javascript
isFinite(NaN) //false
isFinite(Infinity)  //false
isFinite(-Infinity) //false
isFinite(0)  //true
isFinite(132456)  //true
isFinite(-132456)  //true
```

`isFinite()` 会试图把检测到的值转换为一个数字。如果值不是一个数字，那么使用 `isFinite()` 直接检测就不是有效的方法。

```javascript
isFinite('123456')  //true
isFinite('a123456')  //false
```

通过自定义 isNumber 函数可以避免 `isFinite()` 的缺陷。下面自定义函数先判断值是否为数值类型，如果是数值类型，再使用 `isFinite()` 过滤出有效数字。

```javascript
var isNumber = function isNumber(value){
    return typeof value === 'number' && isFinite(value);
}
```

### 使用 `constructor`

**`constructor` 是 Object 类型的原型属性，它能够返回当前对象的构造器（类型函数）。利用该属性，可以检测复合型数据的类型，如对象、数组和函数等。**

下面代码可以检测对象和数组的类型，以此可以过滤对象、数组：

```javascript
var o = {};
var a =[];
if (o.constructor == Object) document.write("o 是对象");
if (a.constructor == Array) document.write("a 是数组");
```

`undefined` 和 `null` 没有 `constructor` 属性，不能够直接读取，否则会抛出异常。因此，一般应先检测值是否为 `undefined` 和 `null` 等特殊值，然后再调用 `constructor` 属性。

```javascript
var value = undefined;
console.log(value && value.constructor);  //返回 undefined
var value = null;
console.log(value && value.constructor);  //返回 null
```

数值直接量也不能直接读取 `constructor` 属性，应该先把它转换为对象再调用。

```javascript
console.log(10.construetor);  //抛出异常
console.log((10).constructor);  //返回 Number 类型
console.log(Number(10).constructor);  //返回 Number 类型
```

### 使用 `toString`

**`toString` 是 Object 类型的原型方法，它能够返回当前对象的字符串表示。利用该属性，可以检测复合型数据的类型，如对象、数组、函数、正则表达式、错误对象、宿主对象、自定义类型对象等；也可以对值类型数据进行检测。**

```javascript
var o = {}; //对象
var a = [1,2]; //数组
var f = function(){}; //函数
console.log(o.toString()); //表示为 "[object Object]"
console.log(a.toString()); //表示为 "1,2"
console.log(f.toString()); //表示为 "function (){}"
```

测试发现，不同类型对象调用 `toString()` 方法时返回的字符串格式并不统一，这是因为不同类型的子类在继承 Object 的原型方法 `toString`，时重写了该方法。如果在对象上调用 Object 的原型方法 `toString()`，就会返回统一格式的字符串表示。例如：

```javascript
var _toString = Object.prototype.toString;  //引用 Objget 的原型方法 toString ()
//使用 apply 方法在对象上动态调用 Object 的原型方法 toString ()
console.log(_toString.apply(o));  //表示为 "[object Object]"
console.log(_toString.apply(a));  //表示为 "[object Array]"
console.log(_toString.apply(f));  //表示为 "[object Function]"
```

## 类型转换

JavaScript 能够根据运算环境自动转换值的类型，以满足运算需要。在自动转换中，JavaScript 一般根据运算的类型环境，按需进行转换。例如，如果在执行字符串为字符串；如果在执行基本数学运算，则会尝试把字符串转换为数值；如果在逻辑运算环境中，则会尝试把值转换为布尔值等。但是在很多情况下需要开发者手动转换数据类型，以控制运算过程。

### 转换为字符串

**加号运算符有两个计算功能**：**数值求和、字符串连接。但是字符串连接操作的优先级要大于求和运算。**因此，在可能的情况下，即运算元的数据类型不一致时，加号运算符会尝试把数值运算元转换为字符串，再执行连接操作。

1) **当值与空字符串相加运算时，JavaScript 会自动把值转换为字符串。**

2) **把数字转换为字符串，返回数字本身。**

```javascript
var n = 123;
n = n + "";
console.log(typeof n); //返回类型为 string
```

3) **把布尔值转换为字符串，返回字符串 "true" 或 "false"。**

```javascript
var b = true;
b = b + "";
console.log(b); //返回字符串"true"
```

4) **把数组转换为字符串，返回数组元素列表，以逗号分隔。如果是空数组，则返回空字符串。**

```javascript
var a = [1,2,3];
a = a + "";
console.log(a); //返回字符串 "1,2,3"
```

5) **把函数转换为字符串，返回函数的具体代码字符串。**

```javascript
var f = function(){return 1;};
f = f + "";
console.log(f);  //返回字符串 "function (){return 1;}"
```

6) **如果是内置类型函数，则只返回构造函数的基本结构，省略函数的具体实现代码。而自定义类型函数与普通函数一样，返回函数的具体实现代码字符串**。

```javascript
d = Date + "";
console.log(d);  //返回字符串 "function Date () { [ native code ] } "
```

如果是内置静态函数，则返回 `[object Class]` 格式的字符串表示。

```javascript
m = Math +"";
console.log(m);  //返回字符串 "[object Math]"
```

7) 但是当多个加号运算符位于同一行时，这个问题就比较复杂。例如：

```javascript
var a = 1 + 1 + "a";
var b= "a" + 1 + 1;
console.log(a);  //返回字符串 "2a"
console.log(b);  //返回字符串"a11"
```

通过上面代码可以看到，加号运算符还会考虑运算的顺序。对于变量 a 来说，按照从左到右的运算顺序，加号运算符会执行求和运算，然后再执行连接操作。但是对于变量 b 来说，由于 "a" + 1 表达式运算将根据连接操作来执行，所以返回字符串 "a1"，然后再用这个字符串与数值 1 进行运算，再次执行连接操作，最后返回字符串 "a11”，而不是字符串 "a2”。

如果要避免此类现象的发生，可以考虑使用小括号运算符来改变表达式的运算顺序。

```javascript
var b = "a" + (1 + 1) ; //返回字符串 "a2"
```

**使用 `toString`：当为简单的值调用 `toString()` 方法时，JavaScript 会自动把它们封装为对象，然后再调用 `toString()` 方法，获取对象的字符串表示。**

```javascript
var a = 123456;
a.toString();
console.log(a);  //返回字符串“123456”
```

?> 使用加号运算符转换字符串，实际上也是调用 `toString()` 方法来完成，只不过是 JavaScript 自动调用 `toString()` 方法实现的。

toString() 方法能够直接输出整数和浮点数，保留小数位。小数位末尾的零会被清除。但是对于科学计数法，则会在条件许可的情况下把它转换为浮点数，否则就用科学计数法形式输出字符串。

```javascript
var c = 1e-1;
console.log(c.toString());  //返回字符串“0.1”
var a = 1e-14;
console.log(a.toString());  //返回字符串“1e-14”
```

**`toFixed()` 能够把数值转换为字符串，并显示小数点后的指定位数。**

```javascript
var a = 10;
console.log(a.toFixed(2));  //返回字符串“10.00”
console.log(a.toFixed(4));  //返回字符串“10.0000”
```

**`toExponential()` 方法专门用来把数字转换为科学计数法形式的字符串。**

```javascript
var a = 123456789;
console.log(a.toExponential(2));  //返回字符串“1.23e+8”
console.log(a.toExponential(4));  //返回字符串“1.2346e+8”
```

**`toPrecision()` 方法与 `toExponential()` 方法相似，但它可以指定有效数字的位数，而不是指定小数位数。**

```javascript
var a = 123456789;
console.log(a.toPrecision(2));  //返回字符串“1.2e+8”
console.log(a.toPrecision(4));  //返回字符串“1.235e+8”
```

### 转换为数字

`parseInt()` 是一个全局方法，它可以把值转换为整数。转换的过程如下：

- 先解析位置 0 处的字符，如果不是有效数字，则直接返回 NaN。
- 如果位置 0 处的字符是数字，或者可以转换为有效数字，则继续解析位置 1 处的字符，如果不是有效数字，则直接返回位置 0 处的有效数字。
- 以此类推，按照从左到右的顺序，逐个分析每个字符，直到发现非数字字符为止。
- `parseInt()` 将把前面分析合法的数字字符全部转换为数值并返回。

```javascript
console.log(parseInt("123abc"));  //返回数字123
console.log(parseInt("1.73"));   //返回数字1
console.log(parseInt(".123"));   //返回值NaN
```

?> 浮点数中的点对于 parseInt() 来说属于非法字符，因此不会转换小数部分的值。

如果是以 0 开头的数字字符串，则 parseInt() 会把它作为八进制数字处理：先把它转换为八进制数值，然后再转换为十进制的数字返回。

如果是以 0x 开头的数字字符串，则 parseInt() 会把它作为十六进制数字处理：先把它转换为十六进制数值，然后再转换为十进制的数字返回。

```javascript
var d = 010;  //八进制数字字符串
var e = 0x10;  //十六进制数字字符串
console.log(parseInt(d));  //返回十进制数字8
console.log(parseInt(e));  //返回十进制数字16
```

【实例1】下面代码把十六进制数字字符串“123abc”转换为十进制整数。

```javascript
var a = "123abc";  console.log(parseInt(a,16));  //返回十进制整数1194684
```


【实例2】下面代码把二进制、八进制和十进制数字字符串转换为十进制的整数。

```javascript
console.log(parseInt("10",2));  //把二进制数字 10 转换为十进制整数，为 2
console.log(parseInt("10",8));  //把八进制数字 10 转换为十进制整数，为 8
console.log(parseInt("10",10));  //把十进制数字 10 转换为十进制整数，为 10
```


【实例3】如果第一个参数是十进制的值，包含 0 前缀，为了避免被误解为八进制的数字，则应该指定第二个参数值为 10，即显示定义基模式，而不是采用默认基模式。

```javascript
console.log(parseInt("010"));  //把默认基模式数字 010 转换为十进制整数为 10
console.log(parseInt("010",8));  //把八进制数字 010 转换为十进制整数为 8
console.log(parseInt("010",10));  //把十进制数字 010 转换为十进制整数为 10
```

`parseFloat()` 也是一个全局方法，它可以把值转换为浮点数，即它能够识别第一个出现的小数点，而第二个小数点被视为非法。解析过程与 parseInt() 方法相同。

```javascript
console.log(parseFloat("1.234.5"));  //返回数值 1.234
```

`parseFloat()` 的参数必须是十进制形式的字符串，而不能使用八进制或十六进制的数字字符串。同时，对于数字前面的 0（八进制数字标识）会忽略，对于十六进制的数字将返回 0。

```javascript
console.log(parseFloat("123"));  //返回数值 123
console.log(parseFloat("123abc"));  //返回数值 123
console.log(parseFloat("010"));  //返回数值 10
console.log(parseFloat("0x10"));  //返回数值 0
console.log(parseFloat("x10"));  //返回数值 NaN
```

**使用乘号运算符**：如果变量乘以 1，则变量会被 JavaScript 自动转换为数值。乘以 1 之后，结果没有发生变化，但是值的类型被转换为数值。如果值无法被缓缓为合法的数值，则返回 NaN。

```javascript
var a = 1;  //数值
var b = "1";  //数字字符串
console.log(a + (b * 1));  //返回数值 2
```

### 转换为布尔值

**1. 使用双重逻辑非**：一个逻辑非运算符!可以把值转换为布尔值并取反，两个逻辑非运算符就可以把值转换为正确的布尔值。

```javascript
console.log(!!0);  //返回false
console.log(!!1);  //返回true
console.log(!!"");  //返回false
console.log(!!NaN);  //返回false
console.log(!!null);  //返回false
console.log(!!undefined);  //返回false
console.log(!![]);  //返回true
console.log(!!{});  //返回true
console.log(!!function(){});  //返回true
```

